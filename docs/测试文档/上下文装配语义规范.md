# 上下文装配语义规范（测试文档）

本文档定义“上下文装配”的可测试语义与验收标准，用于锁定行为，支撑测试先行与 CI 验收。

## 术语

- 工程：用户在画布中构建的上下文工程，包含节点、边、变量与执行配置。
- 节点：画布上的一个上下文片段，具有类型、标签、内容与可选元数据。
- 变量：可被节点内容引用的命名值，分为不变量与变量（后者由执行器求值）。
- 装配：将节点按依赖顺序展开、插值、裁剪并输出为最终上下文的过程。
- Trace：一次装配过程中产生的可观测事件流，包含每个节点/变量的输入输出、耗时与错误等。

## 输入输出契约

### 输入

- 已排序节点列表：由前端或执行器提供，必须为拓扑有序；若存在环，必须在装配前报告错误并阻止输出“成功结果”。
- 变量表：键为变量名，值为字符串或 JSON（后续扩展）。
- 装配选项：包含输出风格、分隔策略、缺失变量处理、裁剪/token 预算策略等。

### 输出

- `text`：最终上下文文本。
- `segments`：按节点划分的分段结果，每段包含：
  - `node_id`、`label`、`kind`、`template`、`rendered`
  - `missing_variables`（若有）
  - `warnings`、`errors`（若有）
- `errors`：全局错误列表（例如输入不合法、装配失败）。

## 装配语义（必须满足）

### 1) 节点顺序

- 节点必须按输入顺序装配，不允许引擎内部重新排序。
- 同一输入在相同变量表与选项下必须输出完全一致结果。

### 2) 分段与分隔

- 每个节点产出一个 segment。
- `text` 为所有 segment 的 `rendered` 以换行分隔的串联结果。
- 分隔符由输出风格决定：
  - `plain`：不添加分隔符，仅以换行拼接。
  - `labeled`：每段以 `--- {label} ---` 开头，再接内容。
  - 未来可扩展为 `chatml` 等结构化风格（本规范先锁定 plain/labeled）。

### 3) 变量插值

- 支持占位符：`{{name}}`，其中 `name` 为变量名（区分大小写）。
- 插值后输出字符串必须是“模板逐项替换”的结果。
- 插值规则：
  - 命中变量：替换为变量字符串值。
  - 缺失变量：保留原占位符不变，并在 segment 里记录 `missing_variables`，同时追加 warning。

### 4) 错误处理

- 输入 JSON 无法解析、字段缺失、类型不匹配等属于“全局错误”，必须返回 `errors`，并避免输出伪成功文本。
- 单个节点内容为空不视为错误，但应正常产出 segment。

## Golden 测试用例（最小集合）

> Golden 用例必须作为自动化测试固化，CI 必跑。

### Case A：基础装配（labeled）

- 节点：
  - n1(label=System, content=`Hello {{name}}`)
  - n2(label=User, content=`Ask: {{q}}`)
- 变量：`name=Alice`、`q=hi`
- 期望：
  - `segments.length=2`
  - `segments[0].rendered` 包含 `Alice`
  - `text` 严格等于：
    - `--- System ---\nHello Alice\n\n--- User ---\nAsk: hi`

### Case B：缺失变量

- 节点：n1(content=`Hello {{missing}}`)
- 变量：空
- 期望：
  - `segments[0].missing_variables=["missing"]`
  - `segments[0].rendered` 仍包含 `{{missing}}`
  - `warnings` 非空

### Case C：空内容

- 节点：n1(content=``)
- 变量：任意
- 期望：无 errors；segment 仍存在。

## 验收标准（CI）

- Rust 单测：通过上述 Golden 用例；输出严格一致。
- 前端单测：Trace UI 能正确显示每个 segment、缺失变量与 warnings。

